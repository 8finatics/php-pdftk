<?php
namespace mikehaertl\pdftk;

use mikehaertl\shellcommand\Command;
use mikehaertl\tmp\File;

/**
 * Pdf
 *
 * This class is a wrapper around pdftk.
 *
 * The class was developed for pdftk 1.44 but should also work with newer versions,
 * but you may have to use slightly different page ranges options (e.g 'east' instead 'E').
 *
 * @author Michael Härtl <haertl.mike@gmail.com>
 * @version 0.1.0-dev
 * @license http://www.opensource.org/licenses/MIT
 */
class Pdf
{
    // The prefix for temporary PDF files
    const TMP_PREFIX = 'tmp_php_pdftk_';

    /**
     * @var string the name of the `pdftk` binary. Default is `pdftk`. You can also
     * configure a full path here.
     */
    public $binary = 'pdftk';

    /**
     * @var array options to pass to the Command constructor. Default is none.
     */
    public $commandOptions = array();

    /**
     * @var bool whether to ignore any errors if some PDF file was still created. Default is false.
     */
    public $ignoreWarnings = false;

    /**
     * @var array list of files to process as array('name' => $filename, 'password' => $pw)
     */
    protected $_files = array();

    /**
     * @var bool whether the Pdf was already processed
     */
    protected $_processed = false;

    /**
     * @var string the applied operation.
     */
    protected $_operation;

    /**
     * @var string|array list of operation args, e.g. page ranges or single arg, e.g. filename
     */
    protected $_operationArgs = array();

    /**
     * @var bool whether to escape the operation argument
     */
    protected $_escapeOperationArg = false;

    /**
     * @var mikehaertl\tmp\File the temporary PDF file
     */
    protected $_tmpPdfFile;

    /**
     * @var Command the command instance that executes pdftk
     */
    protected $_command;

    /**
     * @var int a counter for autogenerated handles
     */
    protected $_handle = 0;

    /**
     * @var string the error message
     */
    protected $_error = '';

    public function __construct($pdf = null)
    {
        if (is_string($pdf)) {
            $this->addFile($pdf);
        } elseif (is_array($pdf)) {
            foreach ($pdf as $handle => $file) {
                $this->addFile($file, $handle);
            }
        }
    }

    /**
     * @param string $name the PDF file to add for processing
     * @param string|null $handle an uppercase letter between A-Z to reference this file later.
     * Newer versions of pdftk also accept a word built from those characteers. If no handle is
     * provided, a internal handle is still autocreated, starting from Z, then Y, X, ...
     * @param string|null $password the owner (or user) password if any
     * @return string the handle for this PDF file which may be required for later reference
     */
    public function addFile($name, $handle = null, $password = null)
    {
        $file = array(
            'name' => $name,
            'password' => $password,
        );
        if ($handle===null) {
            $handle = $this->nextHandle();
        } elseif (!in_array($handle, range('A','Z'))) {
            throw new Exception("Invalid handle provided: '$handle'");
        }
        $this->_files[$handle] = $file;
        return $this;
    }

    /**
     * Assemble (catenate) pages from the input files.
     *
     * Values for rotation are (in degrees): N: 0, E: 90, S: 180, W: 270, L: -90, R: +90,
     * D: +180. L, R and D make relative adjustments to a page's rotation.
     * Newer pdftk versions use north, east, south, west, left, right and down instead.
     *
     * Example:
     *
     *  $pdf = new Pdf;
     *  $pdf->addFile('file1.pdf', 'A')
     *      ->addFile('file2.pdf', 'B')
     *      ->cat(array(1,3),'B'))          // pages 1 and 3 of file B
     *      ->cat(1, 5, 'A', 'odd')         // pages 1, 3, 5 of file A
     *      ->cat('end', 5, 'B')            // pages 5 to end of file B in reverse order
     *      ->cat(null, null, 'B', 'E')     // All pages from file B rotated by 90 degree
     *      ->saveAs('out.pdf');
     *
     * @param int|string|array $start the start page number or an array of page numbers. If an array, the other
     * arguments will be ignored. $start can also be bigger than $end for pages in reverse order.
     * @param int|string|null $end the end page number or null for single page (or list if $start is an array)
     * @param string|null $handle the handle of the file to use. Can be null if only a single file was added.
     * @param string|null $qualifier the page number qualifier, either 'even' or 'odd' or null for none
     * @param string $rotation the rotation to apply to the pages.
     * @return Pdf the pdf instance for method chaining
     */
    public function cat($start, $end = null, $handle = null, $qualifier = null, $rotation = null)
    {
        $this->constrainOperation('cat');
        $this->_operationArgs[] = $this->processPageRange($start, $end, $handle, $qualifier, $rotation);
        return $this;
    }

    /**
     * Shuffle pages from the input files.
     *
     * This works the same as cat(), but each call to this method creates a "stream" of pages. The outfile
     * will be assembled by adding one page from each stream at a time.
     *
     * Example:
     *
     *  $pdf = new Pdf;
     *  $pdf1 = $pdf->addFile('file1.pdf');
     *  $pdf->cat($pdf1, array(1,3,2))
     *      ->cat($pdf1, array(4,5,9)
     *      ->saveAs('out.pdf');
     *
     *  This will give the page order 1, 4, 3, 5, 2, 9 in the out.pdf
     *
     * @param string $handle the handle of the input file to use
     * @param int|array $start the start page number or an array of page numbers.
     * @param int|null $end the end page number or null for single page (or list if $start is an array)
     * @param string|null $qualifier the page number qualifier, either 'even' or 'odd' or null for none
     * @param string $rotation the rotation to apply to the pages. One of north(0°), east(90°), south(180°),
     * west(270°), left(-90°), right(+90°), down(+180°). Left, right and down make relative adjustments to
     * a page's orientation
     * @return Pdf the pdf instance for method chaining
     */
    public function shuffle($start, $end = null, $handle = null, $qualifier = null, $rotation = null)
    {
        $this->constrainOperation('shuffle');
        $this->_operationArgs[] = $this->processPageRange($start, $end, $handle, $qualifier, $rotation);
        return $this;
    }

    /**
     * Split the PDF document into pages
     *
     * @param string|null $name the output name in sprintf format or null for default 'pg_%04d.pdf'
     * @return Pdf the pdf instance for method chaining
     */
    public function burst($name = null)
    {
        throw new \Exception('Not implemented yet');
    }

    /**
     * Generate the FDF file for a single PDF file.
     *
     * @param string $name name of the FDF file
     * @return Pdf the pdf instance for method chaining
     */
    public function generateFdfFile($name)
    {
        throw new \Exception('Not implemented yet');
    }

    /**
     * Fill a PDF form
     *
     * @param string|array $data either a FDF filename or an array with form field data (name => value)
     * @param string the encoding of the data. Default is 'UTF-8'.
     * @return Pdf the pdf instance for method chaining
     */
    public function fillForm($data, $encoding = 'UTF-8')
    {
        $this->constrainOperation('fill_form');
        $this->constrainSingleFile();
        $this->_operationArgs = is_array($data) ? new FdfFile($data, null, null, null, $encoding) : $data;
        $this->_escapeOperationArg = true;
        return $this;
    }

    /**
     * Apply a PDF as watermark to the background of a single PDF file.
     *
     * The PDF file must have a transparent background for the watermark to be visible.
     *
     * @param string $file name of the background PDF file. Only the first page is used.
     * @return Pdf the pdf instance for method chaining
     */
    public function background($file)
    {
        $this->constrainOperation('background');
        return $this;
    }

    /**
     * Apply multiple PDF pages as watermark to the corresponding pages of a single PDF file.
     *
     * If $file has fewer pages than the PDF file then the last page is repeated as background.
     *
     * @param string $file name of the background PDF file.
     * @return Pdf the pdf instance for method chaining
     */
    public function multiBackground($file)
    {
        $this->constrainOperation('multibackground');
        return $this;
    }

    /**
     * Apply a PDF as stamp on top of a single PDF file.
     *
     * The $file should have a transparent background.
     *
     * @param string $file name of the stamp PDF file. Only the first page is used.
     * @return Pdf the pdf instance for method chaining
     */
    public function stamp($file)
    {
        $this->constrainOperation('stamp');
        return $this;
    }

    /**
     * Apply multiple stamps on top of each corresponding page of a single PDF file.
     *
     * If $file has fewer pages than the PDF file then the last page is repeated as stamp.
     *
     * @param string $file name of the stamp PDF file.
     * @return Pdf the pdf instance for method chaining
     */
    public function multiStamp($file)
    {
        $this->constrainOperation('multistamp');
        return $this;
    }

    /**
     * Flatten the PDF form fields values into a single PDF file.
     *
     * @return Pdf the pdf instance for method chaining
     */
    public function flatten()
    {
        return $this;
    }

    /**
     * When combining multiple PDFs, use either the first or last ID in the output.
     * If not called, a new ID is created.
     *
     * @param string $id, either 'first' (default) or 'last'
     * @return Pdf the pdf instance for method chaining
     */
    public function keepId($id = 'first')
    {
        return $this;
    }

    /**
     * Drop XFA data from forms created with Acrobat 7 or Adobe Designer.
     *
     * @return Pdf the pdf instance for method chaining
     */
    public function dropXfa()
    {
        return $this;
    }

    /**
     * @param string $password the owner password to set on the PDF
     * @param int $strength in bit. Either 128 (default) or 40. Note that this will override any strength
     * that was set with setUserPassword() before.
     * @return Pdf the pdf instance for method chaining
     */
    public function setPassword($password, $strength = 128)
    {
        return $this;
    }

    /**
     * @param string $password the owner password to set on the PDF
     * @param int $strength in bit. Either 128 (default) or 40. Note that this will override any strength
     * that was set with setPassword() before.
     * @return Pdf the pdf instance for method chaining
     */
    public function setUserPassword($password, $strength = 128)
    {
        return $this;
    }



    /**
     * Execute the operation and save the output file
     *
     * @param string $name of output file
     * @return bool whether the PDF could be processed and saved
     */
    public function saveAs($name)
    {
        if (!$this->_processed && !$this->process()) {
            return false;
        }
        if (!copy($this->getPdfFilename(),$name)) {
            $this->_error = "Could not copy PDF from tmp location '$tmpFile' to '$filename'";
            return false;
        }
        return true;
    }

    /**
     * Send PDF to client, either inline or as download (triggers PDF creation)
     *
     * @param string|null $filename the filename to send. If empty, the PDF is streamed inline.
     * @param bool $inline whether to force inline display of the PDF, even if filename is present.
     * @return bool whether PDF was created successfully
     */
    public function send($filename=null,$inline=false)
    {
        if (!$this->_processed && !$this->process()) {
            return false;
        }
        $this->_tmpPdfFile->send($filename, 'application/pdf', $inline);
        return true;
    }

    /**
     * @return mikehaertl\shellcommand\Command the command instance that executes pdftk
     */
    public function getCommand()
    {
        if ($this->_command===null) {
            $options = $this->commandOptions;
            if (!isset($options['command'])) {
                $options['command'] = $this->binary;
            }
            $this->_command = new Command($options);
        }
        return $this->_command;
    }

    /**
     * @return string the filename of the temporary PDF file
     */
    public function getPdfFilename()
    {
        if ($this->_tmpPdfFile===null) {
            $this->_tmpPdfFile = new File('', '.pdf', self::TMP_PREFIX);
        }
        return $this->_tmpPdfFile->getFileName();
    }

    /**
     * @return string the error message or an empty string if none
     */
    public function getError()
    {
        return $this->_error;
    }

    /**
     * Convert the page range into a pdftk compatible form
     *
     * @param int|string|array $start the start page number or an array of page numbers. If an array, the other
     * arguments will be ignored. $start can also be bigger than $end for pages in reverse order.
     * @param int|string|null $end the end page number or null for single page (or list if $start is an array)
     * @param string|null $handle the handle of the file to use. Can be null if only a single file was added.
     * @param string|null $qualifier the page number qualifier, either 'even' or 'odd' or null for none
     * @param string $rotation the rotation to apply to the pages.
     * @return string the page range for pdftk
     */
    protected function processPageRange($start, $end = null, $handle = null, $qualifier = null, $rotation = null)
    {
        if (is_array($start)) {
            if ($handle!==null) {
                $start = array_map($start, function ($p) use ($handle) { return $handle.$p; });
            }
            return implode(' ', $start);
        } else {
            $range = $handle.$start;
            if ($end) {
                $range .= '-'.$end;
            }
            return $range.$qualifier.$rotation;
        }
    }

    /**
     * @return bool whether the file was processed successfully
     */
    protected function process()
    {
        if ($this->_processed) {
            return false;
        }
        $command = $this->getCommand();
        $this->addInputFileArguments();
        $this->addOperationArgument();

        $fileName = $this->getPdfFilename();
        $command->addArg('output', $fileName);

        if (!$command->execute()) {
            $this->_error = $command->getError();
            if (!(file_exists($fileName) && filesize($fileName)!==0 && $this->ignoreWarnings)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Add the arguments for PDF input files to the command instance
     */
    protected function addInputFileArguments()
    {
        $command = $this->getCommand();
        $passwords = array();
        foreach ($this->_files as $handle => $file) {
            $command->addArg($handle.'=',$file['name']);
            if ($file['password']!==null) {
                $passwords[$handle] = $file['password'];
            }
        }
        if ($passwords!==array()) {
            $command->addArg('input_pw');
            foreach ($passwords as $handle => $password) {
                $command->addArg($handle.'=', $password);
            }
        }
    }

    /**
     * Add the arguments for the pdftk operation
     */
    protected function addOperationArgument()
    {
        if ($this->_operation!==null) {
            $value = $this->_operationArgs ? $this->_operationArgs : null;
            if ($value instanceof TmpFile) {
                $value = (string) $value;
            }
            $this->getCommand()->addArg($this->_operation, $value, $this->_escapeOperationArg);
        }
    }

    /**
     * Make sure, that only one type of operation is applied on a Pdf
     * @param string $name of the operation
     */
    protected function constrainOperation($name)
    {
        if ($this->_processed) {
            throw new \Exception('Another operation can not be performed after the file was already processed');
        }
        if ($this->_operation!==null && $this->_operation!==$name) {
            throw new \Exception('Only one operation type can be applied to an Pdf object');
        }
        $this->_operation = $name;
    }

    /**
     * Make sure, that only one file is present
     */
    protected function constrainSingleFile()
    {
        if (count($this->_files)>1) {
            throw new \Exception('This operation can only process single files');
        }
    }

    /**
     * @return string the next handle in the series Z, Y, X, ..
     */
    protected function nextHandle()
    {
        $chars = range('Z','A');
        return $chars[$this->_handle++];
    }
}
